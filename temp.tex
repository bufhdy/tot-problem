由此產生一棵最短路徑樹\footnote{這顆樹T的根節點u即爲指定的起點。從根節點u到任一點v的距離即爲圖中u到v的最短路長度}。這一算法是一個籠統的概念，作者和後人都對其進行了實現。我們先不考慮實現的問題，而是用自然語言去描述這一算法的過程。

對每一個\emph{節點}，我們要記錄兩個數據：第一個是\emph{最短路徑的值}，初始化它們爲最大值；另一個是各個點在最短路徑中的前一個元素，稱作\emph{前趨}，初始化爲空，用以在算法主體之後輸出路徑。

維護兩個頂點集合S和Q。前一個集合S保存已經計算的頂點，因此最開始爲空；後一個集合Q保存將要處理的頂點，初始爲圖的頂點集V。

開始進行計算。首先我們把起點的最短路長度賦值爲0（自身到自身，當然爲零）。接着我們進行一個循環，這一循環進行的條件是Q非空，表示當前仍然有代處理的點。在循環中，提取出Q中最短路長度最小的那一個點，命其爲u，並將其放入S。

接下來是這個算法的關鍵部分。對於與u鄰接的每一個節點v，如果現行的v的最短路徑長不是最優，也就是說，頂點u的最短路長加上(u,v)這一條邊的權值，它要小於v的最短路徑長了。這我們就得以這一加和去更新v的最短路徑長了。